<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UI Diff Report</title>
  <style>
    body { font-family: sans-serif; margin: 0.75em; }
    h1, h2, h3, h4 { margin: 0.5em 0 0.25em; }
    #nav { display: flex; flex-wrap: wrap; gap: 0.6em; margin: 0.75em 0; }
    #nav button { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0; border: 2px solid #aaa; border-radius: 6px; cursor: pointer; background: #f5f5f5; overflow: hidden; width: 200px; position: relative; }
    #nav button img { width: 100%; height: auto; display: block; }
    #nav button .nav-title { font-size: 0.82rem; padding-top: 0.3rem; text-align: center; font-weight: 600; }
    #nav button .nav-desc { font-size: 0.60rem; padding: 0.12rem 0.25rem 0.35rem; text-align: center; color: #333; }
    #nav button.active { border-color: #0078d4; background: #e5f2fc; }
    #nav button.active .nav-title { color: #0078d4; }
    #nav button.type-insert { border-color: #2a9d2a; }
    #nav button.type-insert.active { border-color: #1a7a1a; background: #e6f7e6; }
    #nav button.type-delete { border-color: #c0392b; }
    #nav button.type-delete.active { border-color: #922b21; background: #fde8e6; }
    table.videos { width: 100%; }
    .nav-row { display: flex; align-items: center; gap: 8px; width: 100%; }
    .nav-index { position: absolute; left: 8px; bottom: 6px; font-weight: 600; color: #777; font-size: 0.82rem; }
    .nav-index.hidden { display: none; }
    .nav-action { flex: 1; text-align: center; font-size: 0.92rem; font-weight: 600; color: #222; }
    .col-header { display: flex; align-items: center; gap: 1rem; margin: 0 0 6px 0; }
    .col-header h4 { margin: 0; font-size: 1rem; }
    .vid-wrap { display: block; }
    .vid-badge { position: relative; z-index: 2; font-size: 0.78rem; font-weight: 700;
      padding: 4px 8px; border-radius: 4px; pointer-events: none; display: inline-block; }
    .badge-insert { background: #2a9d2a; color: #fff; }
    .badge-delete { background: #c0392b; color: #fff; }
    .badge-replace { background: #d4860a; color: #fff; }
    .badge-none { background: #9aa0a6; color: #fff; }
    @media (max-width: 800px) {
      #nav { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.5em; margin: 0.5em 0; }
      #nav button { width: 100%; }
      table.videos tr { display: flex; flex-direction: column; }
      table.videos td { width: 100% !important; }
    }
  </style>
</head>
<body>
  <h2>UI Diff</h2>
  <p><strong>Results:</strong> $RESULT_TEXT</p>
  <div id='player'></div>
  <div id='nav'></div>
  <script>
    const LABELS = ['Video 1', 'Video 2', 'Pixel Diff'];
    const chunks = $CHUNKS_JSON;

    const TYPE_ICON  = { replace: '✏️', insert: '➕', delete: '➖' };
    const TYPE_BADGE = { replace: 'badge-replace', insert: 'badge-insert', delete: 'badge-delete' };
    const TYPE_NAV   = { replace: '', insert: 'type-insert', delete: 'type-delete' };

    const scenes = [
      { title: 'Full Video', desc: '', type: '', srcs: ['$VIDEO1_SRC', '$VIDEO2_SRC', '$DIFF_SRC'], loop: true },
      ...chunks.map(({ start_frame, end_frame, duration, v1_count, v2_count, type, clips, thumb }, i) => {
        let actionText;
        if (type === 'insert') {
          actionText = `Added ${v2_count} frames`;
        } else if (type === 'delete') {
          actionText = `Removed ${v1_count} frames`;
        } else if (type === 'replace') {
          actionText = (v1_count === v2_count) ? `Changed ${v1_count} Frames` : `Changed ${v1_count}→${v2_count} Frames`;
        } else {
          actionText = `${Math.max(v1_count||0, v2_count||0)} Frames`;
        }
        return {
          idx: i + 1,
          title: actionText || `Group ${i + 1}`,
          desc: `frames ${start_frame + 1}–${end_frame + 1} (${(Math.max(v1_count||0, v2_count||0) / 30.0).toFixed(2)}s)`,
          type: type || '',
          srcs: [clips.video1, clips.video2, clips.diff],
          thumb: thumb || '',
          loop: true,
        };
      }),
    ];

    // Build the static 3-video player; badge spans are toggled per-scene.
    document.getElementById('player').innerHTML = `<table class='videos'><tbody><tr>
      ${LABELS.map((label, i) => `<td width='33%'>
        <div class='col-header'><h4>${label}</h4><span id='badge${i}' class='vid-badge' style='display:none'></span></div>
        <div class='vid-wrap'>
          <video id='v${i}' width='100%' muted playsinline><source type='video/mp4'></video>
        </div>
      </td>`).join('')}
    </tr></tbody></table>`;
    const vids = [0, 1, 2].map(i => document.getElementById(`v${i}`));

    // Whether the current scene should loop (managed manually — NOT via v.loop — so that
    // videos of different lengths don't fight each other through the sync handler).
    let currentLoop = false;

    // True while a collective restart is in flight (prevents re-entrant restart triggers).
    let restarting = false;

    // isEnded: a video counts as "done" once it reaches its natural end.
    const isEnded = v => v.ended || (Number.isFinite(v.duration) && v.currentTime >= v.duration - 0.05);

    // Sync: keep playing videos at the same playhead.
    // Clamp the target time to the destination video's duration so we never force
    // a shorter video past its end via synchronisation.
    vids.forEach(v => {
      v.addEventListener('timeupdate', () => {
        if (restarting) return;
        vids.forEach(o => {
          if (o === v || isEnded(o)) return;
          const target = Number.isFinite(o.duration) ? Math.min(v.currentTime, o.duration) : v.currentTime;
          if (Math.abs(target - o.currentTime) > 0.1) {
            o.currentTime = target;
            if (o.paused) o.play().catch(() => {});
          }
        });
      });

      // When a video ends: pause it and let the longer ones continue.
      // Only restart the whole scene once ALL videos have finished.
      v.addEventListener('ended', () => {
        v.pause();
        if (!restarting && currentLoop && vids.every(isEnded)) {
          restarting = true;
          vids.forEach(v => { v.currentTime = 0; });
          // Brief delay so all currentTime resets settle before we call play().
          setTimeout(() => {
            restarting = false;
            vids.forEach(v => v.play().catch(() => {}));
          }, 50);
        }
      });
    });

    // Switch to a scene: swap sources, reload, play, and update ?selected query param.
    function switchTo(idx) {
      restarting = false;
      vids.forEach(v => { v.pause(); v.loop = false; });   // never use native loop
      const { srcs, loop, type } = scenes[idx];
      currentLoop = loop;

      // Update type badges
      const badgeLabels = { replace: ['changed', 'changed', 'diff'], insert: ['(none)', 'added', 'added'], delete: ['removed', '(none)', 'removed'] };
      const badgeTexts = badgeLabels[type] || ['', '', ''];
      vids.forEach((v, j) => {
        const badge = document.getElementById(`badge${j}`);
        if (type && badgeTexts[j]) {
          badge.textContent = badgeTexts[j];
          // Use a grey 'none' badge when the label is explicitly '(none)'
          const badgeClass = (badgeTexts[j] === '(none)') ? 'badge-none' : (TYPE_BADGE[type] || '');
          badge.className = `vid-badge ${badgeClass}`.trim();
          badge.style.display = '';
        } else {
          badge.style.display = 'none';
        }
        v.querySelector('source').src = srcs[j];
        v.load();
        v.play().catch(() => {});
      });

      document.querySelectorAll('#nav button').forEach((b, j) => b.classList.toggle('active', j === idx));
      const newUrl = new URL(window.location);
      idx > 0 ? newUrl.searchParams.set('selected', idx) : newUrl.searchParams.delete('selected');
      history.replaceState(null, '', newUrl);
    }

    // Build nav buttons (hide the nav entirely when there are no diff segments).
    const navEl = document.getElementById('nav');
    if (scenes.length > 1) {
      scenes.forEach((s, i) => {
        const b = document.createElement('button');
        const navClass = TYPE_NAV[s.type];
        if (navClass) b.classList.add(navClass);
        if (s.thumb) {
          const img = document.createElement('img');
          img.src = s.thumb;
          img.alt = s.title;
          b.appendChild(img);
        }
        const header = document.createElement('div');
        header.className = 'nav-row';
        const idxEl = document.createElement('span');
        idxEl.className = 'nav-index';
        if (s.idx) {
          idxEl.textContent = s.idx + '.';
        } else {
          idxEl.classList.add('hidden');
        }
        const actionEl = document.createElement('span');
        actionEl.className = 'nav-action';
        const icon = TYPE_ICON[s.type] || '';
        actionEl.textContent = (icon ? icon + ' ' : '') + s.title;
        header.appendChild(actionEl);
        header.appendChild(idxEl);
        const desc = document.createElement('span');
        desc.className = 'nav-desc';
        desc.textContent = s.desc || '';
        b.title = ((s.title || '') + (s.desc ? ' — ' + s.desc : '')).trim();
        b.appendChild(header);
        b.appendChild(desc);
        b.onclick = () => switchTo(i);
        navEl.appendChild(b);
      });
    } else {
      navEl.style.display = 'none';
    }

    // On load: if ?selected=N is present, select that scene; otherwise default to 0.
    (function selectInitialFromQuery() {
      const params = new URLSearchParams(window.location.search);
      const v = parseInt(params.get('selected') || '0', 10);
      const initial = (!Number.isNaN(v) && v >= 0 && v < scenes.length) ? v : 0;
      switchTo(initial);
    })();
  </script>
</body>
</html>
