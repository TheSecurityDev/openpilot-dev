from __future__ import annotations
from typing import TYPE_CHECKING
from collections.abc import Callable
from dataclasses import dataclass

from cereal import log
from openpilot.selfdrive.ui.tests.diff.replay import FPS, ReplayContext
from openpilot.selfdrive.ui.tests.diff.replay_setup import (
  put_update_params, setup_offroad_alerts, setup_update_available, setup_developer_params,
  make_network_state_setup, make_onroad_setup, make_alert_setup,
)

WAIT = int(FPS * 0.5)  # Default frames to wait after events

AlertSize = log.SelfdriveState.AlertSize
AlertStatus = log.SelfdriveState.AlertStatus


@dataclass
class ScriptEvent:
  if TYPE_CHECKING:
    # Only import for type checking to avoid excluding the application code from coverage
    from openpilot.system.ui.lib.application import MouseEvent

  setup: Callable | None = None  # Setup function prior to adding mouse events
  mouse_events: list[MouseEvent] | None = None  # Mouse events to send to the application on this frame


ScriptEntry = tuple[int, ScriptEvent]  # (frame, event)


class Script:
  def __init__(self, fps: int):
    self.fps = fps
    self.frame = 0
    self.entries: list[ScriptEntry] = []

  def get_frame_time(self) -> float:
    return self.frame / self.fps

  def add(self, event: ScriptEvent, before: int = 0, after: int = 0):
    """Add event to the script, optionally with the given number of frames to wait before or after the event."""
    self.frame += before
    self.entries.append((self.frame, event))
    self.frame += after

  def end(self):
    """Add a final empty event to mark the end of the script."""
    # Without this, it will just end on the last event without waiting for any specified delay after it
    self.add(ScriptEvent())

  def wait(self, frames: int):
    """Add a delay for the given number of frames followed by an empty event."""
    self.add(ScriptEvent(), before=frames)

  def setup(self, fn: Callable, wait_after: int = WAIT):
    """Add a setup function to be called immediately followed by a delay of the given number of frames."""
    self.add(ScriptEvent(setup=fn), after=wait_after)

  def click(self, x: int, y: int, wait_after: int = WAIT, wait_between: int = 0):
    """Add a click event to the script for the given position and specify frames to wait between mouse events or after the click."""
    from openpilot.system.ui.lib.application import MouseEvent, MousePos

    mouse_down = MouseEvent(pos=MousePos(x, y), slot=0, left_pressed=True, left_released=False, left_down=False, t=self.get_frame_time())
    self.add(ScriptEvent(mouse_events=[mouse_down]), after=wait_between)
    mouse_up = MouseEvent(pos=MousePos(x, y), slot=0, left_pressed=False, left_released=True, left_down=False, t=self.get_frame_time())
    self.add(ScriptEvent(mouse_events=[mouse_up]), after=wait_after)


def build_mici_script(ctx: ReplayContext, script: Script):
  """Build the replay script for the mici layout."""
  from openpilot.system.ui.lib.application import gui_app

  center = (gui_app.width // 2, gui_app.height // 2)

  script.wait(FPS)
  script.click(*center, FPS)  # Open settings
  script.click(*center, FPS)  # Open toggles
  script.end()


def build_tizi_script(ctx: ReplayContext, script: Script):
  """Build the replay script for the tizi layout."""

  def make_home_refresh_setup(fn: Callable):
    """Return setup function that calls the given function to modify state and forces an immediate refresh on the home layout."""
    from openpilot.selfdrive.ui.layouts.main import MainState

    def setup():
      fn()
      ctx.main_layout._layouts[MainState.HOME].last_refresh = 0

    return setup

  # TODO: Better way of organizing the events

  # === Homescreen ===
  script.setup(make_network_state_setup(ctx, log.DeviceState.NetworkType.wifi))

  # === Offroad Alerts (auto-transitions via HomeLayout refresh) ===
  script.setup(make_home_refresh_setup(setup_offroad_alerts))

  # === Update Available (auto-transitions via HomeLayout refresh) ===
  script.setup(make_home_refresh_setup(setup_update_available))

  # === Settings - Device (click sidebar settings button) ===
  script.click(150, 90, wait_between=1)  # wait 1 frame between mouse down and up to avoid clicking close button immediately when opened

  # === Settings - Network ===
  script.click(278, 450)

  # === Settings - Toggles ===
  script.click(278, 600)

  # === Settings - Software ===
  script.setup(put_update_params, wait_after=0)
  script.click(278, 720)

  # === Settings - Firehose ===
  script.click(278, 845)

  # === Settings - Developer (set CarParamsPersistent first) ===
  script.setup(setup_developer_params, wait_after=0)
  script.click(278, 950)

  # === Keyboard modal (SSH keys button in developer panel) ===
  script.click(1930, 470)  # click SSH keys
  script.click(1930, 115)  # click cancel on keyboard

  # === Close settings ===
  script.click(250, 160)

  # === Onroad ===
  script.setup(make_onroad_setup(ctx))
  script.click(1000, 500)  # click onroad to toggle sidebar

  # === Onroad alerts ===
  # Small alert (normal)
  script.setup(make_alert_setup(ctx, AlertSize.small, "Small Alert", "This is a small alert", AlertStatus.normal))
  # Medium alert (userPrompt)
  script.setup(make_alert_setup(ctx, AlertSize.mid, "Medium Alert", "This is a medium alert", AlertStatus.userPrompt))
  # Full alert (critical)
  script.setup(make_alert_setup(ctx, AlertSize.full, "DISENGAGE IMMEDIATELY", "Driver Distracted", AlertStatus.critical))
  # Full alert multiline
  script.setup(make_alert_setup(ctx, AlertSize.full, "Reverse\nGear", "", AlertStatus.normal))
  # Full alert long text
  script.setup(make_alert_setup(ctx, AlertSize.full, "TAKE CONTROL IMMEDIATELY", "Calibration Invalid: Remount Device & Recalibrate", AlertStatus.userPrompt))

  # End
  script.end()


def build_script(context: ReplayContext, big=False) -> list[ScriptEntry]:
  """Build the replay script for the appropriate layout variant and return list of script entries."""
  print(f"Building replay script (big={big})...")

  script = Script(FPS)
  builder = build_tizi_script if big else build_mici_script
  builder(context, script)

  print(f"Built replay script with {len(script.entries)} events and {script.frame} frames ({script.get_frame_time():.2f} seconds)")

  return script.entries
